#!/bin/bash

# catree - Recursively concatenate files
# Proof of Concept

# Default values
INCLUDE_EXTS=""
EXCLUDE_EXTS=""
USE_GITIGNORE=false
PIPE_CMD=""
TARGETS=()

# Function to show help
show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Recursively concatenate files in the current directory or specified paths.

OPTIONS:
    -h              Show this help message
    -f PATH         Specific file or folder to display (can be used multiple times)
    -inc EXTS       List of extensions to include (comma-separated, e.g., "txt,md,sh")
    -exc EXTS       List of extensions to exclude (comma-separated, e.g., "log,tmp")
    -gitignore      Respect .gitignore patterns and exclude ignored files
    -pipe CMD       Pipe each file through a command (e.g., "bat", "pygmentize -g")

EXAMPLES:
    $(basename "$0")                             # Cat all files
    $(basename "$0") -inc "txt,md"               # Only .txt and .md files
    $(basename "$0") -exc "log,tmp"              # Exclude .log and .tmp files
    $(basename "$0") -gitignore                  # Respect .gitignore
    $(basename "$0") -pipe "bat --paging=never"  # Display with bat
    $(basename "$0") -f README.md                # Single file
    $(basename "$0") -f src                      # All files under src/
    $(basename "$0") -f src -f tests             # Multiple folders
    $(basename "$0") -f src/main.py -f docs      # Mix files and folders

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h)
            show_help
            exit 0
            ;;
        -f)
            TARGETS+=("$2")
            shift 2
            ;;
        -inc)
            INCLUDE_EXTS="$2"
            shift 2
            ;;
        -exc)
            EXCLUDE_EXTS="$2"
            shift 2
            ;;
        -gitignore)
            USE_GITIGNORE=true
            shift
            ;;
        -pipe)
            PIPE_CMD="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1" >&2
            show_help
            exit 1
            ;;
    esac
done

# Helper: build find filters
build_find_filters() {
    local cmd=""

    if [ -n "$INCLUDE_EXTS" ]; then
        IFS=',' read -ra EXTS <<< "$INCLUDE_EXTS"
        cmd+=" \\("
        for i in "${!EXTS[@]}"; do
            [ $i -gt 0 ] && cmd+=" -o"
            cmd+=" -name \"*.${EXTS[$i]}\""
        done
        cmd+=" \\)"
    fi

    if [ -n "$EXCLUDE_EXTS" ]; then
        IFS=',' read -ra EXTS <<< "$EXCLUDE_EXTS"
        for ext in "${EXTS[@]}"; do
            cmd+=" ! -name \"*.${ext}\""
        done
    fi

    echo "$cmd"
}

# Print a single file
print_file() {
    local file="$1"

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "▶ File: $file"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [ -n "$PIPE_CMD" ]; then
        eval "$PIPE_CMD \"$file\""
    else
        cat "$file"
    fi
    echo ""
}

# If specific targets are provided
if [ ${#TARGETS[@]} -gt 0 ]; then
    FILTERS=$(build_find_filters)

    for target in "${TARGETS[@]}"; do
        if [ -f "$target" ]; then
            print_file "$target"

        elif [ -d "$target" ]; then
            eval "find \"$target\" -type f $FILTERS" | while read -r file; do
                print_file "$file"
            done

        else
            echo "Warning: Path not found: $target" >&2
        fi
    done
    exit 0
fi

# Default behavior (current directory)
FIND_CMD="find . -type f $(build_find_filters)"

echo "Executing: $FIND_CMD"
echo "---"

eval "$FIND_CMD" | while read -r file; do
    print_file "$file"
done

